<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="iOS开发">
<meta property="og:type" content="website">
<meta property="og:title" content="鲨鱼辣椒">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;3&#x2F;index.html">
<meta property="og:site_name" content="鲨鱼辣椒">
<meta property="og:description" content="iOS开发">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>鲨鱼辣椒</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">鲨鱼辣椒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/20/e5-88-86-e4-ba-ab-e4-b8-80-e4-b8-aabing-e5-a3-81-e7-ba-b8-e6-8e-a5-e5-8f-a3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangshengyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鲨鱼辣椒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/20/e5-88-86-e4-ba-ab-e4-b8-80-e4-b8-aabing-e5-a3-81-e7-ba-b8-e6-8e-a5-e5-8f-a3/" itemprop="url">分享一个Bing壁纸接口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-20T18:50:04+08:00">
                2017-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/" itemprop="url" rel="index">
                    <span itemprop="name">Home</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>分享一个Bing壁纸的API，速度还挺快的，也挺稳定的。之前想写个能把Bing每日壁纸设置成壁纸的应用，找了一圈儿API没一个好用的。

顺便撸了个展示数据的demo，地址：[https://github.com/ssssuperMan/BingImage](https://github.com/ssssuperMan/BingImage)

API地址：[https://github.com/xCss/bing](https://github.com/xCss/bing) 感谢作者的劳动成果。</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/12/this-application-is-modifying-the-autolayout-engine-from-a-background-e7-9a-84-e8-a7-a3-e5-86-b3-e6-96-b9-e6-a1-88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangshengyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鲨鱼辣椒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/12/this-application-is-modifying-the-autolayout-engine-from-a-background-e7-9a-84-e8-a7-a3-e5-86-b3-e6-96-b9-e6-a1-88/" itemprop="url">This application is modifying the autolayout engine from a background 的解决方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T14:56:35+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/" itemprop="url" rel="index">
                    <span itemprop="name">未分类</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这个错误的出现一般都是因为在子线程当中刷新UI造成的，只要用dispatch_async(dispatch_get_main_queue(), ^(void){ <code> });包裹一下就好了，但是Xcode报错的信息十分的模糊，基本上没有什么可用的信息，也找不出到底是哪个地方的UI放在了子线程中刷新。</p>
<p>解决方法就是有个一个<a href="https://gist.github.com/steipete/5664345" target="_blank" rel="noopener">PSPDFUIKitMainThreadGuard.m</a>的文件是从PSPDFKit中抽离出来的判断UI进程的文件，这是一个在 PSPDFKit 框架中用到的专门查找代码中哪些代码会在辅线程中更新 UI 的工具，但已经修改为支持 MIT 协议了，因此你可以在自己的项目中使用它。它会在背后拦截所有 UIKit 中对 setNeedsDisplay 和 setNeedsLayout 的调用。将这个文件的编译选项设置为 -fno-objc-arc。试着编译一下，如果顺利的话，你就可以找出项目中那些错误地在辅线程中更新 UI 的代码了。</p>
<p>这样就能找到问题所在了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/21/ios8-e5-8f-8a-e4-bb-a5-e4-b8-8a-e4-b8-8a-e4-bc-a0-e5-8e-9f-e5-9b-be-e4-bb-a5-e5-8f-8a-e5-8e-9f-e8-a7-86-e9-a2-91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangshengyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鲨鱼辣椒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/21/ios8-e5-8f-8a-e4-bb-a5-e4-b8-8a-e4-b8-8a-e4-bc-a0-e5-8e-9f-e5-9b-be-e4-bb-a5-e5-8f-8a-e5-8e-9f-e8-a7-86-e9-a2-91/" itemprop="url">iOS8及以上上传原图以及原视频</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-21T11:14:36+08:00">
                2017-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/" itemprop="url" rel="index">
                    <span itemprop="name">Home</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2017年12月16日17-08-58更新"><a href="#2017年12月16日17-08-58更新" class="headerlink" title="2017年12月16日17:08:58更新"></a>2017年12月16日17:08:58更新</h2><ul>
<li><p>视频上传这块后期代码还是优化了，为了解决上传视频的时候内存过大的问题现在的做法是创建<code>socket</code>任务的时候给上<code>tag</code>值，然后根据这个tag值来判断这个任务上传的这一片数据是否上传完毕，然后再创建下一个任务，当一个任务新建的时候上个任务已经被释放了，这样的话内存的占用就可以维持在一个很稳定的数值上下。</p>
</li>
<li><p>iPhone 7出来之后苹果默认的照片格式是<code>HEIF</code>也就是Live图，这个图目前想做到原图上传，我没有太好的解决方案，现在我们的做法仍然是使用<code>PhotoKit</code>将后缀名为<code>HEIF</code>的图片转换成<code>JPG</code>格式的照片，然后“原图上传”。（虽然现在已经不存在什么原图了）</p>
</li>
<li><p>&gt; <em>“NSData(contentsOfFile: String&gt;, options: NSDataReadingOptions.DataReadingMappedAlways)是可以不让内存暴增，但是这个貌似是有大小限制的，太大的文件比如2G的文件就不行了，使用NSInputSteam的话可以从特定位置截取一段数据上传吗？”</em></p>
</li>
</ul>
<p>这个问题当时是我提出来的，现在我看有人给我推荐了一个方法：</p>
<pre><code>_stream = [[NSInputStream alloc]initWithFileAtPath:self.srcFilePath];
[_stream setProperty:[NSNumber numberWithUnsignedLongLong:self.srcFileFinishedSize] forKey:NSStreamFileCurrentOffsetKey];

可以从某个offset开始读取流，实现断点上传。</code></pre><p>这个方法我当时应该也尝试过，但是不太能够满足我的需求，但是可能大家的使用场景都不一样，所以我还是把这个方法贴出来，大家看能不能提供一种思路。</p>
<h2 id="以下是原文："><a href="#以下是原文：" class="headerlink" title="以下是原文："></a>以下是原文：</h2><p>iPhone手机相册中的图片的默认格式都是jpg的，假设我把一张bmp或者gif等其他格式的图片保存到本地相册那么上传到服务器的话就需要判断图片是哪种格式的，然后做出相应的操作。同理，视频也是这样如果我们需要上传原图原视频是需要处理一下的。</p>
<blockquote>
<p>文章大概分为三个部分： 一、怎么上传相册中各种格式的原图上传。 二、怎么上传各种格式的原视频。 三、上传大图片以及大视频面临的内存优化问题。</p>
</blockquote>
<p>一、<strong>上传bmp、gif、jpg、png等格式的原图上传（前提是后台也支持接受各种格式）</strong></p>
<pre><code>//imagePickerController代理方法
-(void)imagePickerController:(UIImagePickerController )picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString ,id&gt; )info {
//获取原始文件的URL，注意这个地方的URL并不是沙盒中的物理路径，而是一个AssetURL，只能使用系统提供的AssetsLibrary框架进行访问。
    NSURL assetURL = info[UIImagePickerControllerReferenceURL];
    //根据URL创建PHFetchResult对象。
    PHFetchResult fetchResult = [PHAsset fetchAssetsWithALAssetURLs:@[assetURL] options:nil];
    //获取PHAsset
    PHAsset asset = [fetchResult firstObject];
@autoreleasepool {
                PHImageManager imageManager = [[PHImageManager alloc] init];
                [imageManager requestImageDataForAsset : assets options :nil resultHandler:^(NSData  _Nullable imageData, NSString  _Nullable dataUTI, UIImageOrientation orientation, NSDictionary  _Nullable info) {

                    UIImage photo = [UIImage imageWithData: imageData];
                    BOOL downloadFinined = (![[info objectForKey : PHImageCancelledKey] boolValue] &amp;&amp; ![info objectForKey : PHImageErrorKey]);
                    if (downloadFinined &amp;&amp; imageData) {//这个地方的imageData为原图的二进制数据
                        [weakSelf updataImageWithArray : photo index:i amount : assets.count imageData : imageData];
                    }
                    //用来判断图片的格式
                    //if ([dataUTI isEqualToString:(__bridge NSString )kUTTypeJPEG]) {}
                    //如果不想在这个地方进行格式判断，也可是在下面调用的方法中根据imageData判断文件头来判断文件格式
                }];
            }
}</code></pre><p><strong>二、上传原视频</strong></p>
<pre><code>//imagePickerController代理方法
    -(void)imagePickerController:(UIImagePickerController )picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString ,id&gt; )info {
        //获取原始文件的URL，注意这个地方的URL并不是沙盒中的物理路径，而是一个AssetURL，只能使用系统提供的AssetsLibrary框架进行访问。
        NSURL assetURL = info[UIImagePickerControllerReferenceURL];
        //根据URL创建PHFetchResult对象。
        PHFetchResult fetchResult = [PHAsset fetchAssetsWithALAssetURLs:@[assetURL] options : nil];
        //获取PHAsset
        PHAsset asset = [fetchResult firstObject];
        //创建导出视频的选项
        PHVideoRequestOptions videoOptions = [[PHVideoRequestOptions alloc] init];
        //设置导出版本为PHVideoRequestOptionsVersionOriginal，原图选项。但是这个地方的视频仍然会被压缩。
        videoOptions.version = PHVideoRequestOptionsVersionOriginal;
        [[PHImageManager defaultManager] requestExportSessionForVideo : asset options : videoOptions exportPreset : AVAssetExportPresetHighestQuality resultHandler:^(AVAssetExportSession  _Nullable exportSession, NSDictionary  _Nullable info) {
            NSDateFormatter formater = [[NSDateFormatter alloc] init];
            [formater setDateFormat:@”yyyy - MM - dd - HH : mm : ss”];
            //读取到沙盒中
            NSString videoPath = [NSHomeDirectory() stringByAppendingFormat:@”/Library/Caches/output-%@.%@”, [formater stringFromDate:[NSDate date]],[assetURL pathExtension]];
            //设置导出地址
            exportSession.outputURL = [NSURL fileURLWithPath: videoPath];
            //设置导出文件类型
            exportSession.outputFileType = [self chooseVideoType:[assetURL pathExtension]];
            //导出
            [exportSession exportAsynchronouslyWithCompletionHandler:^{
                switch (exportSession.status) {
                    case AVAssetExportSessionStatusCompleted:{
                    //转成NSData用来上传，使用dataWithContentsOfFile：options：error方法并不会把数据全部加载进内存里面,而是使用内存映射的方式获取NSData。不会导致内存暴增而导致崩溃。
                    NSData data = [NSData dataWithContentsOfFile : videoPath options : NSDataReadingMappedIfSafe error : nil];
                        NSLog(@”%ld”,data.length);
                    }
                        break;
                    default:
                        break;
                }
            }];
        }];
    }

    //这个地方试试链式语法
    -(NSString )chooseVideoType:(NSString )videoType {
        if ([videoType isEqualToString:@”MOV”]) {
            return AVFileTypeQuickTimeMovie;
        }else if ([videoType isEqualToString:@”MP4”]) {
            return AVFileTypeMPEG4;
        }
        return nil;
    }</code></pre><p>首先，我必须得说一下就是使用UIImagePickerController来选择上传视频，在选择之后，系统会自动帮你压缩，这个步骤暂时是去不掉的。具体参考Stack Overflow的答案，因为这一块的资料也比较少，根据我掌握的资料来看还是需要使用PhotoKit的API。 对于沙盒中的大文件上传具体是有两个方法来避免上传时直接拷贝到内存导致内存占用过大导致崩溃。<a href="http://www.jianshu.com/p/157cb9d5350b" target="_blank" rel="noopener">简书一个作者的心血总结</a> 第一个方法就是使用推荐使用<code>NSInputStream(fileAtPath: fileUrl)</code>初始化为文件流，不占内存。也可以使用<code>NSData(contentsOfFile: String&amp;gt;, options: NSDataReadingOptions.DataReadingMappedAlways)</code>，使用内存映射的方式获取NSData。关于内存映射的问题，他提供了一个Stack Overflow的答案 而第一种方法我暂时没有时间去研究，他是这么说的： 对于系统相册的文件，在此处具体来说就是一个ALAsset对象，我们能够通过<code>ALAssetRepresentation</code>的<code>getBytes</code>方法获取到文件的内容到一段缓冲区，继而生成NSData，但是这个NSData并不是内存映射的，所以文件多大，就会占用多少内存。</p>
<pre><code>let rept =  asset.defaultRepresentation()
let imageBuffer = UnsafeMutablePointer&lt;UInt8&gt;.alloc(Int(rept.size()))
let bufferSize = rept.getBytes(imageBuffer, fromOffset: Int64(0),length: Int(rept.size()), error: nil)
let data =  NSData(bytesNoCopy:imageBuffer ,length:bufferSize, freeWhenDone:true)
此时我们需要把ALAsset转化为NSInputStream，通过CFStreamCreateBoundPair这个类。在苹果的官方文档上有对这个类的使用场景介绍，但是没有官方例子。

For large blocks of constructed data, call CFStreamCreateBoundPair to create a pair of streams, then call the setHTTPBodyStream: method to tell NSMutableURLRequest to use one of those streams as the source for its body content. By writing into the other stream, you can send the data a piece at a time.</code></pre><p>根据官方文档，以及我收集的资料，具体的做法是使用<code>CFStreamCreateBoundPair</code>创建一对<code>readStream/writeStream</code>，<code>readStream</code>就作为<code>HTTPBodyStream</code>，设置<code>NSStream</code>的代理，<code>writeStream</code>加入<code>Runloop</code>，监测其<code>NSStreamEvent</code>是<code>HasSpaceAvailable</code>时，调用<code>getBytes</code>方法获取一段<code>NSData</code>，写入到<code>writeStream</code>中。主要的代码如下。</p>
<pre><code>func stream(aStream: NSStream, handleEvent eventCode: NSStreamEvent) {
    switch (eventCode) {
    case NSStreamEvent.None:
        break

    case NSStreamEvent.OpenCompleted:
        break

    case NSStreamEvent.HasBytesAvailable:
        break

    case NSStreamEvent.HasSpaceAvailable:
        self.write()
        break

    case NSStreamEvent.ErrorOccurred :
        self.finish()
        break
    case NSStreamEvent.EndEncountered:
        // weird error: the output stream is full or closed prematurely, or canceled.
        self.finish()
        break
    default:
        break
    }
}

func write() {
    let rept =  asset.defaultRepresentation()
    let length = self.assetSize - self.offset &amp;gt; self.bufferSize ? self.bufferSize :  self.assetSize - self.offset
    if length &amp;gt; 0 {
        let writeSize = rept.getBytes(assetBuffer, fromOffset: self.offset ,length: length, error:nil)
        let written = self.writeStream.write(assetBuffer, maxLength: writeSize)
        self.offset += written
    } else {
        self.finish()
    }
}

func finish() {
    self.writeStream.close()
    self.writeStream.removeFromRunLoop(NSRunLoop.currentRunLoop(), forMode: NSRunLoopCommonModes)
    self.strongSelf = nil
}</code></pre><p>完整的代码我上传在了github，<code>ALAssetToNSInputStream</code>，把<code>ALAssetToNSInputStream.swift</code>加入工程即可使用，Demo暂时还没有，有时间会补上。 这是作者这个工程的GitHub，我猜测就是类似于socket做大文件上传的实现方式，就是使用系统提供的C函数来实现的部分功能。 <strong>三、上传大文件时的内存优化问题</strong> 这个问题我在上面的两个问题里面其实都已经提到过了。大致有几个思路。 1.对于普通的上传文件会创建大量的UIImage对象，使用ARC的话可能内存不会及时的释放，所以我们可以在适当的地方手动加上自动释放池。 2.对于在沙盒中的文件可以使用contentWithFile等方法转化成NSData，通过映射的方式可以解决这个问题。 3.就是使用socket的方式进行上传。等我有时间写个demo放到GitHub上吧。 4.分片上传，这个方法我也只是在各大论坛听说可以这样实现，具体实现我并没有写过，继续研究吧。 总结：接触的越多发现不会的越多，发现还是有很多需求其实挺难实现的。这算是PhotoKit框架的初体验吧。因为我们的项目不支持iOS8以下，所以需要支持iOS8一下的同学，可以在网上找找实现方法，都差不多的，有的API貌似比iOS8之后的还好用一些。就这么些吧，等想到了再补充。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/15/e5-85-b3-e4-ba-8e-e5-87-bd-e6-95-b0-e5-bc-8f-e7-bc-96-e7-a8-8b-e5-92-8c-e9-93-be-e5-bc-8f-e7-bc-96-e7-a8-8b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangshengyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鲨鱼辣椒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/15/e5-85-b3-e4-ba-8e-e5-87-bd-e6-95-b0-e5-bc-8f-e7-bc-96-e7-a8-8b-e5-92-8c-e9-93-be-e5-bc-8f-e7-bc-96-e7-a8-8b/" itemprop="url">关于函数式编程和链式编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-15T13:43:00+08:00">
                2017-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/" itemprop="url" rel="index">
                    <span itemprop="name">Home</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第一次接触函数式编程和链式语法是在使用Masonry，感觉就是很新颖。比如这样：</p>
<p>make.top.equalTo(self.view).offset(50)；</p>
<p>像这样用点语法，将需要执行的代码连起来，这就是链式编程，这样使代码简介易读，书写方便。</p>
<p>像equalTo(self.view) 这样，通过（）去调用函数，就是函数式编程。</p>
<p>下面我们来看看如何实现函数式编程和链式编程：</p>
<p>一、首先是使用 [ ] 来实现连续调用：</p>
<p>//<br>//  ResponseObject.h<br>//  函数式链式编程<br>//<br>//  Created by 张声扬 on 2017/2/15.<br>//  Copyright © 2017年 张声扬. All rights reserved.<br>//</p>
<p>-(ResponseObject *)responseObjectFirst;<br>-(ResponseObject *)responseObjectSecond;</p>
<p>//  ResponseObject.m<br>//  函数式链式编程</p>
<p>#pragma mark - 用[] 实现连续调用<br>-(ResponseObject *)responseObjectFirst {<br>    NSLog(@”%s”,__FUNCTION__);<br>    return self;<br>}</p>
<p>-(ResponseObject *)responseObjectSecond {<br>    NSLog(@”%s”,__FUNCTION__);<br>    return self;<br>}</p>
<p>调用的时候是这样的：</p>
<p>//用[] 实现连续调用<br>[[self responseObjectFirst] responseObjectSecond];</p>
<p>二、用（）实现函数式编程</p>
<p>//  ResponseObject.h<br>//  函数式链式编程<br>-(void (^)())responseObjectThree;<br>-(void (^)())responseObjectFour;</p>
<p>#pragma mark - 用（）实现函数式编程<br>-(void (^)())responseObjectThree {<br>    void(^responseBlock)() = ^{<br>        NSLog(@”%s”,__FUNCTION__);<br>    };<br>    return responseBlock;<br>}</p>
<p>-(void (^)())responseObjectFour {<br>    void(^responseBlock)() = ^{<br>        NSLog(@”%s”,__FUNCTION__);<br>    };<br>    return responseBlock;<br>}</p>
<p>调用是这样的：</p>
<p>//用（）实现函数式编程<br>self.responseObjectThree();<br>self.responseObjectFour();</p>
<p>三、链式 + 函数式 无参数 实现</p>
<p>//  ResponseObject.h<br>//  函数式链式编程<br>-(ResponseObject * (^)())responseObjectFive;<br>-(ResponseObject * (^)())responseObjectSix;</p>
<p>#pragma mark - 函数式 + 链式 无参数<br>-(ResponseObject * (^)())responseObjectFive {<br>    ResponseObject * (^responseBlock)() = ^{<br>        NSLog(@”%s”,__FUNCTION__);<br>        return self;<br>    };<br>    return responseBlock;<br>}</p>
<p>-(ResponseObject *(^)())responseObjectSix {<br>    ResponseObject * (^responseBlock)() = ^{<br>        NSLog(@”%s”,__FUNCTION__);<br>        return self;<br>    };<br>    return responseBlock;<br>}</p>
<p>调用：</p>
<p>//函数式 + 链式 无参数<br>self.responseObjectFive().responseObjectSix();</p>
<p>四、链式 + 函数式 有参数 </p>
<p>//  ResponseObject.h<br>//  函数式链式编程<br>-(ResponseObject * (^)(NSString *name,NSString *detail)) responseObjectSeven;<br>-(ResponseObject * (^)(NSString *name,NSString *detail))responseObjectEight;</p>
<p>#pragma mark - 函数式 + 链式 有参数<br>-(ResponseObject <em>(^)(NSString *, NSString *))responseObjectSeven {<br>    ResponseObject * (^responseBlock)() = ^(NSString \</em>name, NSString *detail) {<br>        NSLog(@”%s”,__FUNCTION__);<br>        return self;<br>    };<br>    return responseBlock;<br>}</p>
<p>-(ResponseObject <em>(^)(NSString *, NSString *))responseObjectEight {<br>    ResponseObject *(^responseBlock)() = ^(NSString \</em>name, NSString *detail) {<br>        NSLog(@”%s”,__FUNCTION__);<br>        return self;<br>    };<br>    return responseBlock;<br>}</p>
<p>调用：</p>
<p>//函数式 + 链式 有参数<br>self.responseObjectSeven(@”zhangsan”, @”detail:zhangsan”).responseObjectEight(@”lisi”, @”detail:lisi”);</p>
<p>好了到这，应该就明白链式和函数式编程是怎么回事了，如果想再深入的了解一下的话建议还是通读一下Masonry的源码，相信会有一个很大的进步。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/e4-b8-8a-e4-bc-a0-e5-9b-be-e7-89-87-e9-81-87-e5-88-b0-e7-9a-84-e5-9d-91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangshengyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鲨鱼辣椒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/13/e4-b8-8a-e4-bc-a0-e5-9b-be-e7-89-87-e9-81-87-e5-88-b0-e7-9a-84-e5-9d-91/" itemprop="url">上传图片遇到的坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-13T13:02:05+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/" itemprop="url" rel="index">
                    <span itemprop="name">Home</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>如果前后台配合默契的话做个图片上传也只是分分钟的事情，最近遇到了一个时间比较久的项目，后台在最初的接口写的是单张上传，前端代码也是根本没打算以后拓展的意思。好了，现在要做多张图片上传，现在在这记录一下具体实现。</code></pre><p>首先面临的问题有：</p>
<pre><code> 1.一次只能上传一张，那么上传多张的话就只能遍历图片数组一张一张上传。

2.如果只是简单的在for循环里面上传图片的话，根本不会成功，for循环里面的异步请求方法会瞬间执行完毕，成功的话也只能成功上传最后一张图片。

 3.可以在for循环里面写上同步请求的方法，如果你觉着用户体验并不觉的差的话。



 首先作为一个有原则的程序员，第三点在我体验过效果之后果断放弃了，同步上传线程堵塞，连菊花都转不了，体验太差了。

 解决方案有几种，我是选择了使用GCD实现，下面上实现代码：</code></pre><p>-(void)updataImageWithArray:(UIImage *)photo index:(NSInteger) i amount:(NSInteger)sum{<br>    dispatch_group_t group = dispatch_group_create();</p>
<pre><code>dispatch\_group\_enter(group);

//刷新单行
NSIndexPath *indexPath = \[NSIndexPath indexPathForRow:2 inSection:0\];
\[self.tableView reloadRowsAtIndexPaths:\[NSArray arrayWithObjects:indexPath, nil\] withRowAnimation:(UITableViewRowAnimationNone)\];

NSData *nataSmall = (UIImageJPEGRepresentation(image1, 1));
//转码base64
NSString *imageData = \[nataSmall base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength\];

\_fileName = \[NSString stringWithFormat:@&quot;%@\_%@\_blogs\_%ld.png&quot;,self.PictureModel.user_id,date,i\];
AFHTTPSessionManager *manager = \[AFHTTPSessionManager manager\];
manager.responseSerializer = \[AFHTTPResponseSerializer serializer\];
NSString *str1 = \[NSString stringWithFormat:@&quot;%@newMobile/syn.do&quot;,self.PicturePinJie\];

NSDictionary *paras = @{};

\[manager POST:str1 parameters:paras success:^(NSURLSessionDataTask *task, id responseObject) {

    NSLog(@&quot;第 %d 张图片上传成功: %@&quot;, (int)i + 1, responseObject);
    @synchronized (responseArray) {
        // NSMutableArray 是线程不安全的，所以加个同步锁
        \[responseArray addObject:responseObject\];
    }
    dispatch\_group\_leave(group);

} failure:^(NSURLSessionDataTask \*task, NSError \*error) {
    if (error) {
        NSLog(@&quot;第 %d 张图片上传失败: %@&quot;, (int)i + 1, error);
        \[MBProgressHUD showError:@&quot;网络连接失败，请重试&quot;\];
        dispatch\_group\_leave(group);
    }
}\];

dispatch\_group\_notify(group, dispatch\_get\_main_queue(), ^{
    NSLog(@&quot;上传完成!&quot;);
});</code></pre><p>}</p>
<pre><code>解释一下，首先使用dispatch\_group\_create来创建dispatch_group，然后把每一个请求任务创建之前先执行enter操作，任务完成之后执行leave操作。当group中的任务全部都执行完毕的时候就会自动执行notify中的代码。这样的话就相当于每个任务都是不想关的一部分，至于开启了多少线程，是由系统分配的，这样就实现了同时、多张、异步的上传图片的需求。还有一点需要注意的是，由于多个线程同时操作保存请求回来数据的可变数组，所以线程是不安全的，在这里我需要加上同步锁，以免发生数据竞争的问题。</code></pre><p>其实使用信号量也能解决这个问题，而且GCD中还有一些其他的API组合起来也能解决这个问题。不得不感叹GCD确实是一项划时代的技术。我还查找了一些资料可以监控上传进度等一些其他的方法，我把资料地址附上，有需要的话，大家自己研究一下，并不难。</p>
<p>AFNetworking 3 批量上传图片 一次上传多张图片<br><a href="http://www.ablanxue.com/shtml/201611/35226_1.shtml" target="_blank" rel="noopener">http://www.ablanxue.com/shtml/201611/35226_1.shtml</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/10/mac-e4-b8-8b-e8-ae-be-e7-bd-aeterminal-e8-b5-b0-e4-bb-a3-e7-90-86-e7-9a-84-e6-96-b9-e6-b3-95-e3-80-82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangshengyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鲨鱼辣椒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/10/mac-e4-b8-8b-e8-ae-be-e7-bd-aeterminal-e8-b5-b0-e4-bb-a3-e7-90-86-e7-9a-84-e6-96-b9-e6-b3-95-e3-80-82/" itemprop="url">Mac下设置Terminal走代理的方法。</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-10T17:27:47+08:00">
                2017-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/" itemprop="url" rel="index">
                    <span itemprop="name">Home</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天用CocoaPods更新网易云信的SDK更新了俩小时没有更新成功，就想着能不能让终端也走个代理，在网上找到了方法记录一下。</p>
<p>1.使用终端 open ~/.gitconfig。</p>
<p>2、添加本地代理地址：</p>
<p>[http]<br>proxy = socks5://127.0.0.1:1080</p>
<p>[https]<br>proxy = socks5://127.0.0.1:1080</p>
<p>但是这样做的话，在后来的使用中我发现并不是所有的情况都能这么干，今天用Alcatraz下载Xcode插件的时候报错：<img src="/wp-content/uploads/2017/01/20170110032542_77383.png" alt=""></p>
<p>解决办法就是把添加进去的那两行给删掉，用的时候再添加上喽。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/22/e5-85-b3-e4-ba-8eblock-e5-be-aa-e7-8e-af-e5-bc-95-e7-94-a8-e7-9a-84-e9-97-ae-e9-a2-98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangshengyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鲨鱼辣椒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/22/e5-85-b3-e4-ba-8eblock-e5-be-aa-e7-8e-af-e5-bc-95-e7-94-a8-e7-9a-84-e9-97-ae-e9-a2-98/" itemprop="url">关于Block循环引用的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-22T18:50:17+08:00">
                2016-12-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/" itemprop="url" rel="index">
                    <span itemprop="name">Home</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>来看一个例子，我们有两个控制器类，一个叫ViewController，另一个叫HYBAController。其中，ViewController有一个按钮，点击时会push到HYBAController下。</p>
<p>HYBAController</p>
<p>// 公开了一个方法<br>- (instancetype)initWithCallback:(HYBCallbackBlock)callback;</p>
<p>// 非公开的属性，这里放出来只是告诉大家，HYBAController会对这个属性强引用<br>@property (nonatomic, copy) HYBCallbackBlock callbackBlock;</p>
<p>ViewController</p>
<p>@interface ViewController ()</p>
<p>// 引用按钮只是为了测试<br>@property (nonatomic, strong) UIButton *button;<br>// 只是为了测试内存问题，引用之。在开发中，有很多时候我们是<br>// 需要引用另一个控制器的，因此这里模拟之。<br>@property (nonatomic, strong) HYBAController *vc;</p>
<p>@end</p>
<p>// 点击button时<br>- (void)goToNext {<br>  HYBAController *vc = [[HYBAController alloc]initWithCallback:^{<br>    [self.button setTitleColor:[UIColor greenColor] forState:UIControlStateNormal];<br>  }];<br>  self.vc = vc;<br>  [self.navigationControllerpushViewController:vcanimated:YES];<br>}</p>
<p>现在我们就来分析一下，这段代码是不是有循环引用的问题（当然有啊，没有我就不写出来了）。</p>
<p>首先从 ViewController 的 goToNext方法说起，callback持有ViewController，而ViewController持有HYBAController，</p>
<p>HYBAController持有callbackBlock。</p>
<p>callback -&gt; ViewController -&gt; HYBAController -&gt; callbackBlock  </p>
<p>这就形成了一个循环引用，解决办法是在callbackBlock中对ViewController的引用改为弱引用：</p>
<p>- (void)goToNext {<br>  __weak __typeof(self) weakSelf = self;<br>  HYBAController *vc = [[HYBAController alloc]initWithCallback:^{<br>    [weakSelf.buttonsetTitleColor:[UIColor greenColor]forState:UIControlStateNormal];<br>  }];<br>//  self.vc = vc;<br>  [self.navigationControllerpushViewController:vcanimated:YES];<br>}</p>
<p>还有就是一开发者认为在block中不使用点语法直接访问属性合成的成员变量就不会持有当前对象了，看下面代码：</p>
<p>- (void)goToNext {<br>  __weak __typeof(self) weakSelf = self;<br>  HYBAController *vc = [[HYBAController alloc]initWithCallback:^{<br>    [_button setTitleColor:[UIColor greenColor] forState:UIControlStateNormal];<br>  }];</p>
<p>  [self.navigationControllerpushViewController:vcanimated:YES];<br>}</p>
<p>实际上则不然，因为实例变量是和self所指代的实例关联在一起的，如果通过读取或者写入方法持有了实例变量，那么也  </p>
<p>会把self一块持有。</p>
<p>还有一种循环引用比上一种更加难以发现：</p>
<p>EOCNerworkFetcher.h<br>typedef void (^EOCNetworkFetcherCompletionHandler) (NSData *data);<br>@propery (nonatomic, strong) NSUrl *url;<br>@propery (nonatomic, copy) EOCNetworkFetcherCompletionHandler  completionHandler;</p>
<p>EOCNerworkFetcher.m<br>-(void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler )completionHandler {<br>    self.completionHandler = completionHandler;<br>    //请求完成后设置_downloadData<br>    //请求完成后，调用p_requestCompled<br>}<br>-（void）p_requestCompled {<br>    if (_completionHandler ) {<br>        _completionHandler(_downloadData);<br>    }<br>}</p>
<p>在另外的类中请求数据：</p>
<p>-(void)downloadData {<br>    NSUrl *url = [NSUrl alloc ] initwithUrl………];<br>    EOCNerworkFetcher    *nerworkFetcher = [EOCNerworkFetcher alloc] initwithUrl:url];<br>    [nerworkFetcher startWithCompletionHandler:^(NSData *data){<br>        NSLog(@”%@”,nerworkFetcher.url);<br>        _fetchedData = data;<br>    }]<br>}</p>
<p>completionHandler块会根据获取器对象来访问url，于是块就保留了获取器，而获取器把completionHandler设成了</p>
<p>属性保留了这个快，解决办法是运行过completionHandler之后就没有必要保留他了，解决办法如下：</p>
<p>-(void) p_requestCompled {<br>   if (_completionHandler) {<br>      _completionHandler(_downloadData);<br>   }<br>   self.completionHandler = nil;<br>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/06/socket-ef-bc-88-e4-ba-8c-ef-bc-89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangshengyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鲨鱼辣椒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/06/socket-ef-bc-88-e4-ba-8c-ef-bc-89/" itemprop="url">Socket（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-06T15:06:35+08:00">
                2016-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/" itemprop="url" rel="index">
                    <span itemprop="name">Home</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>Socket（一）是对一些基本概念的描述，这篇就说一下Socket具体在iOS中是怎么实现通信的。</code></pre><h2 id="一、建立连接"><a href="#一、建立连接" class="headerlink" title="   一、建立连接"></a>   一、建立连接</h2><pre><code>1.定义输入输出流。</code></pre><p>- (void)connectToHost:(id)sender {<br>   //定义服务器的地址和端口号<br>   NSString *host = @”127.0.0.1”;<br>    int port = 12345;</p>
<pre><code>// 定义C语言输入输出流
CFReadStreamRef readStream;
CFWriteStreamRef writeStream;
CFStreamCreatePairWithSocketToHost(NULL, (__bridge CFStringRef)host, port, &amp;readStream, &amp;writeStream);

// 把C语言的输入输出流转化成OC对象
\_inputStream = (\_\_bridge NSInputStream *)(readStream);
\_outputStream = (\_\_bridge NSOutputStream *)(writeStream);


// 设置代理
_inputStream.delegate = self;
_outputStream.delegate = self;


// 把输入输入流添加到主运行循环
// 不添加主运行循环 代理有可能不工作
\[_inputStream scheduleInRunLoop:\[NSRunLoop mainRunLoop\] forMode:NSDefaultRunLoopMode\];
\[_outputStream scheduleInRunLoop:\[NSRunLoop mainRunLoop\] forMode:NSDefaultRunLoopMode\];

// 打开输入输出流
\[_inputStream open\];
\[_outputStream open\];</code></pre><p>}</p>
<pre><code>2.实现登录</code></pre><p>-（void）login{<br>    //登录的指令，格式是自己定义的，跟后台商量<br>    NSString *loginStr = @”iam:zhangsan”;</p>
<pre><code>//把Str转成NSData
NSData *data = \[loginStr dataUsingEncoding:NSUTF8StringEncoding\];

\[_outputStream write:data.bytes maxLength:data.length\];</code></pre><p>}</p>
<pre><code>3.NSStreamDelegate 代理方法，从一开始的时候代理方法就已经在执行了。</code></pre><p>-(void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode{<br>//打印结果为主线程，说明事件的处理是在主线程。<br>    NSLog(@”%@”,[NSThread currentThread]);</p>
<p>//    NSStreamEventOpenCompleted = 1UL &lt;&lt; 0,//输入输出流打开完成<br>//    NSStreamEventHasBytesAvailable = 1UL &lt;&lt; 1,//有字节可读<br>//    NSStreamEventHasSpaceAvailable = 1UL &lt;&lt; 2,//可以发放字节<br>//    NSStreamEventErrorOccurred = 1UL &lt;&lt; 3,// 连接出现错误<br>//    NSStreamEventEndEncountered = 1UL &lt;&lt; 4// 连接结束<br>    switch (eventCode) {<br>        case NSStreamEventOpenCompleted:<br>            NSLog(@”输入输出流打开完成”);<br>            break;<br>        case NSStreamEventHasBytesAvailable:<br>            NSLog(@”有字节可读”);<br>            [self readData];<br>            break;<br>        case NSStreamEventHasSpaceAvailable:<br>            NSLog(@”可以发送字节”);<br>            break;<br>        case NSStreamEventErrorOccurred:<br>            NSLog(@” 连接出现错误”);<br>            break;<br>        case NSStreamEventEndEncountered:<br>             NSLog(@”连接结束”);</p>
<pre><code>        // 关闭输入输出流
        \[_inputStream close\];
        \[_outputStream close\];

        // 从主运行循环移除
        \[_inputStream removeFromRunLoop:\[NSRunLoop mainRunLoop\] forMode:NSDefaultRunLoopMode\];
        \[_outputStream removeFromRunLoop:\[NSRunLoop mainRunLoop\] forMode:NSDefaultRunLoopMode\];
        break;
    default:
        break;
}   </code></pre><p>}</p>
<pre><code>4.readData读取数据的方法</code></pre><p>-(void)readData{</p>
<pre><code>//建立一个缓冲区 可以放1024个字节
uint8_t buf\[1024\];

// 返回实际装的字节数
NSInteger len = \[_inputStream read:buf maxLength:sizeof(buf)\];

// 把字节数组转化成字符串
NSData *data = \[NSData dataWithBytes:buf length:len\];

// 从服务器接收到的数据
NSString *recStr =  \[\[NSString alloc\] initWithData:data encoding:NSUTF8StringEncoding\];

NSLog(@&quot;%@&quot;,recStr);

\[self reloadDataWithText:recStr\];</code></pre><p>}</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/06/socket-ef-bc-88-e4-b8-80-ef-bc-89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangshengyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鲨鱼辣椒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/06/socket-ef-bc-88-e4-b8-80-ef-bc-89/" itemprop="url">Socket（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-06T14:53:20+08:00">
                2016-12-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/" itemprop="url" rel="index">
                    <span itemprop="name">Home</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>最近一直忙着赶项目很长时间没有写东西了，惭愧。最近突然发现Socket这些东西长时间不用，都忘得差不多了。写出来记录一下，一是加深记忆复习巩固，二是可以经常拿出来看看。

OSI、TCP\\IP参考模型</code></pre><hr>
<pre><code>![](/wp-content/uploads/2016/12/20161206003529_99210.png)

一图胜千言，简单解释一下：</code></pre><ol>
<li><p>物理层：主要定义物理设备标准，如网线的接口类型、各种传输介质的传输速率等。</p>
</li>
<li><p>数据链路层：主要将从物理层接收的数据进行MAC地址的封装与解封装。</p>
</li>
<li><p>网络层：选择合适的网间路由和交换结点，确保数据及时传送，将从下层接收到的数据进行IP地址的封装与解封装。</p>
</li>
<li><p>传输层：定义了一些传输数据的协议和端口，如TCP、UDP协议，主要将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，以往把这一层数据叫做段。</p>
</li>
<li><p>会话层：通过传输层建立数据传输通路。</p>
</li>
<li><p>表示层：主要是进行对接收的数据进行解释、压缩与解压缩等，即把计算机能够识别的东西转化成人能够识别的东西（如图片、声音等）。</p>
</li>
<li><p>应用层：主要是一些终端的应用，比如说FTP（各种文件下载）、浏览器、QQ等，可以将其理解为在电脑屏幕上可以看到的东西，也就是终端应用。</p>
</li>
</ol>
<pre><code>网络通讯要素：</code></pre><hr>
<pre><code>   IP地址：网络中设备的标识。

   端口号：用来标识进程的逻辑地址，不同的进程的标示。（比如服务器上面跑着多项任务，一个端口号对应着一个任务）。

   传输协议：用什么样的方式进行交互，常见协议TCP/IP。



TCP/UDP</code></pre><hr>
<pre><code>TCP:</code></pre><ol>
<li><p>建立连接，形成数据传输通道。</p>
</li>
<li><p>传输数据的大小不受限制。</p>
</li>
<li><p>可靠协议，安全送达，三次握手。</p>
</li>
<li><p>每次都需要建立连接，效率较低。</p>
<p>  UDP:</p>
</li>
<li><p>不需要建立连接，将数据装在数据包中。</p>
</li>
<li><p>每个数据包的大小都有限制64K以内。</p>
</li>
<li><p>不建立连接，是不可靠协议。</p>
</li>
<li><p>不用建立连接，效率较高。</p>
<p> Socket</p>
</li>
</ol>
<hr>
<pre><code> ![](/wp-content/uploads/2016/12/20161206005046_76625.png)      



1.网络提供服务的一种机制

2.通信的两端都是socket

3.网络通信其实就是socket间的通信

4.数据在两个socket间通过IO传输</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/06/e9-80-a0-e8-bd-ae-e5-ad-90-ef-bc-9azsyframeautoscale-e5-b1-8f-e5-b9-95-e9-80-82-e9-85-8d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangshengyang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鲨鱼辣椒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/06/e9-80-a0-e8-bd-ae-e5-ad-90-ef-bc-9azsyframeautoscale-e5-b1-8f-e5-b9-95-e9-80-82-e9-85-8d/" itemprop="url">造轮子：ZSYFrameAutoScale屏幕适配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-06T16:53:23+08:00">
                2016-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/" itemprop="url" rel="index">
                    <span itemprop="name">Home</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Home/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.再开发过程当中我一般都是使用initWithFrame:来创建一个控件的：</p>
<p>[code lang=”objc”]&lt;br /&gt;<br /> UISearchBar *tempDoctorSearchBar = [[UISearchBar alloc] initWithFrame:CGRectMake(0, NAV_HEIGHT, maxWidth, SEARCH_BAR_HEIGHT)];&lt;br /&gt;<br /> [self.view addSubview:tempDoctorSearchBar];&amp;lt;/pre&amp;gt;&lt;br /&gt;<br /> [/code]</p>
<p>这样写是没有错但是当切换当前设备的时候尺寸就会改变，比如在iPhone 6 固定的高度到了iPhone 6 +上位置就会不对，并且每次这样写都很麻烦，有没有解决的办法呢？我们先来看看各个设备的长宽比：</p>
<p>设备</p>
<p>宽高比</p>
<p>iPhone 5/ 5s</p>
<p>320 / 568 = 0.563</p>
<p>iPhone 6/ 6s</p>
<p>375 / 667 = 0.562</p>
<p>iPhone6+</p>
<p>424 / 736 = 0.5625</p>
<p>各个设备的宽高比都是差不多的，所以我们可以把不同的尺寸按照伸缩比移植到各个设备上。这个就是大致的思路。</p>
<p>[code lang=”objc”]&lt;br /&gt;<br /> // 在AppDelegate.h中@property float autoSizeScaleX;&lt;br /&gt;<br /> @property float autoSizeScaleY;&lt;br /&gt;<br /> // 在AppDelegate.m中&lt;br /&gt;<br /> #define ScreenHeight [[UIScreen mainScreen] bounds].size.height&lt;br /&gt;<br /> #define ScreenWidth [[UIScreen mainScreen] bounds].size.width&lt;br /&gt;<br /> - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {&lt;br /&gt;<br /> AppDelegate *myDelegate = [[UIApplication sharedApplication] delegate]; if(ScreenHeight &amp;amp;gt; 480){ // 这里以(iPhone4S)为准&lt;br /&gt;<br /> myDelegate.autoSizeScaleX = ScreenWidth/320;&lt;br /&gt;<br /> myDelegate.autoSizeScaleY = ScreenHeight/568;&lt;br /&gt;<br /> }else{&lt;br /&gt;<br /> myDelegate.autoSizeScaleX = 1.0;&lt;br /&gt;<br /> myDelegate.autoSizeScaleY = 1.0;&lt;br /&gt;<br /> }&lt;br /&gt;<br /> }&lt;br /&gt;<br /> [/code]</p>
<p>因为iPhone4s屏幕的高度是480, 因此当屏幕尺寸大于iPhone4时, autoSizeScaleX和autoSizeScaleY即为当前屏幕和iPhone5尺寸的宽高比, 比如,<br>如果是5，autoSizeScaleX=1，autoSizeScaleY=1；<br>如果是6，autoSizeScaleX=1.171875，autoSizeScaleY=1.17429577；<br>如果是6Plus，autoSizeScaleX=1.29375，autoSizeScaleY=1.2957；<br>现在我们获取了比例关系后，先来看一下如何解决代码设置界面时的适配。CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height)这个方法使我们常用的设置尺寸的方法，现在我设置了一个类似于这样的方法。在.m文件中</p>
<p>[code lang=”objc”]&lt;br /&gt;<br /> CG_INLINE CGRectTS_CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height)&lt;br /&gt;<br /> {&lt;br /&gt;<br /> AppDelegate *myDelegate = [[UIApplication sharedApplication] delegate]; CGRect rect;&lt;br /&gt;<br /> rect.origin.x = x * myDelegate.autoSizeScaleX;&lt;br /&gt;<br /> rect.origin.y = y * myDelegate.autoSizeScaleY;&lt;br /&gt;<br /> rect.size.width = width * myDelegate.autoSizeScaleX;&lt;br /&gt;<br /> rect.size.height = height * myDelegate.autoSizeScaleY; return rect;&lt;br /&gt;<br /> }&lt;br /&gt;<br /> [/code]</p>
<p>如果整个项目做完后才开始做适配的话这个方法的优势就体现出来了,面对几十个工程文件,只需自定义并且替换你的CGRectMake方法,再加上storyBoradAutoLay这个方法就瞬间完成大部分甚至全部的适配,如果遇到tableView的或者其他的手动调整一下即可.</p>
<p>这个我已经设计了一个类，欢迎交流。</p>
<p>Github:<a href="https://github.com/ssssuperMan/ZSYFrameAutoScale" target="_blank" rel="noopener">https://github.com/ssssuperMan/ZSYFrameAutoScale</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">&lt;i class=&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zhangshengyang</p>
              <p class="site-description motion-element" itemprop="description">iOS开发</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangshengyang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
